<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      fastdlabs
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/styles.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">
</head>


  <body>
    <nav class="nav">
      <div class="nav-container">
        <a href="/">
          <h2 class="nav-title">fastdlabs</h2>
        </a>
        <ul>
          <li><a href="/about">About</a></li>
          <li><a href="/">Posts</a></li>
        </ul>
    </div>
  </nav>

    <main>
      <div class="catalogue">
  
    <a href="/2017-12-21/architecture" class="catalogue-item">
      <div>
        <time datetime="2017-12-21 00:00:00 +0800" class="catalogue-time">December 21, 2017</time>
        <h1 class="catalogue-title">浅谈架构</h1>
        <div class="catalogue-line"></div>

        <p>
          当架构规划的结果，整理出一堆不同优先级的需求，尤其是质量需求之后，接下来就要思考如何才能最大限度地实现这些需求，这就是架构设计要解决的问题。那么，如何进行架构设计呢？设计到什么程度才合适呢？我从架构思维和架构原则方面来思考架构设计的问题。 架构思维 这里说的架构思维是指进行架构设计时最高层级的思考方式，比如：面向过程、面向对象、面向切面、面向服务等。 面向过程(Procedure Oriented) 面向过程的设计思路就是将问题分解成一个个步骤，按照步骤一步步执行之后，问题就解决了。每一个步骤就是一个子过程，也可以称为一个模块，子过程还可以继续拆分成更多更细的子过程。因此，面向过程的设计核心就是过程分析、功能分解，一般采用自顶向下、逐步求精的分解方式。一个大的程序可以分解成多个子程序，子程序再分解成多个大模块，大模块再分解成多个小模块，最终分解成一个个函数。 在此我想借用一个象棋对战的例子，例子来源于一篇很老的文章：架构师之路(4)—详解面向对象。以下是采用面向过程的设计思路分解的对战流程图：  将以上每个流程分别用函数实现，问题就解决了。 面向过程的优点主要有两个：一是流程清晰简单；二是性能比较高。尤其是性能，这也是为什么至今很多单片机开发、驱动程序开发、或其他与硬件相关的系统开发等对性能要求很高的软硬件程序依然在用面向过程的方式进行设计和开发。 面向过程的缺点也很明显：一是主程序太重，主程序与模块承担的任务不均衡；二是函数不易扩展，导致其可扩展性、可复用性、可维护性相对都比较差；三是上下层级模块之间的联系太紧密，耦合高，所以模块也难以复用。 面向对象(Object Oriented) 面向过程的思路是“怎么做”，关注于实现细节；而面向对象的思路是“谁来做”，关注于抽象的对象。对象的封装、继承和多态等特性，让我们以更接近现实世界的方式来思考程序设计。面向对象相比面向过程容易实现更好的分离，相应地可扩展性、可复用性、可维护性也会比较高，但同时会牺牲掉一些性能。不过，也因为硬件发展迅猛，所以牺牲的那点性能也不算什么了。 面向对象设计的难点在于抽象，从问题域中抽象出一个个对象，并找出它们之间的关系。好在有SOLID原则和一大堆设计模式指导我们如何更好地设计。也有领域驱动设计的方法论指导我们怎么进行领域建模。 还是象棋对战的例子，用面向对象的设计思路，可以抽象出以下三种对象：  棋手：负责行棋，红黑两方行为一致。 棋盘：负责绘制棋盘画面。 裁判：负责判定吃子、犯规和输赢等。  三者关系如下图： <img src="http://keeganlee.me/architecture/_image/20160621/13-56-53.jpg"...
        </p>

      </div>
    </a>
  
    <a href="/2017-12-21/RESTful-API" class="catalogue-item">
      <div>
        <time datetime="2017-12-21 00:00:00 +0800" class="catalogue-time">December 21, 2017</time>
        <h1 class="catalogue-title">浅谈RESTful API</h1>
        <div class="catalogue-line"></div>

        <p>
          大家都在讨论如何设计 RESTful API，我也来谈谈我对API设计的一些想法。 迄今为止，我个人认为，API设计较为好的是 github，可以去看看 github 的设计，点击这里。 我个人认为，想要设计好一个好看，易理解的API，首先得自己理解，而最基本的，应该是 url 的意义了吧，我相信，很多人都不完全知道 url 到底是啥，代表什么，仅仅是知道，是一个访问地址而已。 wiki 原文: wiki  统一资源定位符（或称统一资源定位器/定位地址、URL地址等[1]，英语：Uniform / Universal Resource Locator，常缩写为URL），有时也被俗称为网页地址（网址）。如同在网络上的门牌，是因特网上标准的资源的地址（Address）。它最初是由蒂姆·伯纳斯-李发明用来作为万维网的地址。现在它已经被万维网联盟编制为因特网标准RFC 1738。 在因特网的历史上，统一资源定位符的发明是一个非常基础的步骤。统一资源定位符的语法是一般的，可扩展的，它使用ASCII代码的一部分来表示因特网的地址。统一资源定位符的开始，一般会标志着一个计算机网络所使用的网络协议。  那么设计一个较为优秀的 RESTful API 应该具备些什么条件呢?...
        </p>

      </div>
    </a>
  
    <a href="/2017-12-12/create-zipkin" class="catalogue-item">
      <div>
        <time datetime="2017-12-12 00:00:00 +0800" class="catalogue-time">December 12, 2017</time>
        <h1 class="catalogue-title">FastD最佳实践六: 创建Zipkin调用链监控</h1>
        <div class="catalogue-line"></div>

        <p>
          zipkin是一个开放源代码分布式的跟踪系统，由Twitter公司开源，它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。它的理论模型来自于Google Dapper 论文。 为什么要使用 zipkin 随着业务发展，系统拆分导致系统调用链路愈发复杂一个前端请求可能最终需要调用很多次后端服务才能完成，当整个请求变慢或不可用时，我们是无法得知该请求是由某个或某些后端服务引起的，这时就需要解决如何快读定位服务故障点，以对症下药。于是就有了分布式系统调用跟踪的诞生。而zipkin就是开源分布式系统调用跟踪的佼佼者 安装 zipkin wget -O zipkin.jar 'https://search.maven.org/remote_content?g=io.zipkin.java&amp;a=zipkin-server&amp;v=LATEST&amp;c=exec' java -jar zipkin.jar  安装 Molten 此处提供一个 C 扩展，为php提供对应的数据收集。地址: 点击我 安装参考:...
        </p>

      </div>
    </a>
  
    <a href="/2017-12-12/create-monitor" class="catalogue-item">
      <div>
        <time datetime="2017-12-12 00:00:00 +0800" class="catalogue-time">December 12, 2017</time>
        <h1 class="catalogue-title">FastD最佳实践四: 创建可视化监控</h1>
        <div class="catalogue-line"></div>

        <p>
          原有监控系统  整个系统以 Graphite (carbon + whisper) 为核心, kong 通过 statsd plugin 将服务调用信息发送至 statsd, 而 statsd 则将统计信息通过 Web API 保存至Graphite . 最终在...
        </p>

      </div>
    </a>
  
    <a href="/2017-12-12/create-log" class="catalogue-item">
      <div>
        <time datetime="2017-12-12 00:00:00 +0800" class="catalogue-time">December 12, 2017</time>
        <h1 class="catalogue-title">FastD最佳实践五: 创建ELK日志分析</h1>
        <div class="catalogue-line"></div>

        <p>
          过去咱们开发中，对日志这个环节其实并不太重视，直到有一天，应用出现异常，这个时候才想起来“日志”，但很可惜，为时已晚。 咱们做运维和开发，除了救火，还需要防火，因此一些防范的意识也是非常重要的。 效果图  安装ELK 安装 ELK 是相对简单的，但是后期也需要对其进行优化，适当考虑运维人力，如果觉得个人可以折腾的不放可以尝试。 如果已经存在 ELK 环境，可以直接跳过，进行框架日志配置环节。 点击前往: 中文地址 先决条件: Java 8 sudo add-apt-repository -y...
        </p>

      </div>
    </a>
  
    <a href="/2017-12-12/create-gatewray" class="catalogue-item">
      <div>
        <time datetime="2017-12-12 00:00:00 +0800" class="catalogue-time">December 12, 2017</time>
        <h1 class="catalogue-title">FastD最佳实践三: 创建API网关</h1>
        <div class="catalogue-line"></div>

        <p>
          构建完成 API 服务，配置中心之后，架构图大致如下:  我们为何需要网关 引用 别人 的一句话:  我们总是听到编排这个词，所以我喜欢这张幻灯片 – 它展示了一个乐队，然后有个指挥家，下面一堆人（微型服务）演奏自己的乐器。这个指挥家（API网关）可以以某种方式来协调我们的架构如何处理请求。  我们需要将业务或服务放置在网关背后，由网关统一处理请求入口，本身由多个入口的处理变成了一个入口，由网关进行统一调度。  有一个很nice的事情，就是API网关让我们的客户端不用再需要知道和关心模块的地址（address）了。网关负责来搞这些事情，你只需要知道网关就好了。你可以去改变实现而且还可以改变API接口。不过通常来说，你改变接口后，会增加客户端出问题的风险。  还有很多有趣的功能，有兴趣的朋友可以参考:  微服务与API 网关（上）: 为什么需要API网关？ 微服务与API...
        </p>

      </div>
    </a>
  
    <a href="/2017-12-12/create-configure" class="catalogue-item">
      <div>
        <time datetime="2017-12-12 00:00:00 +0800" class="catalogue-time">December 12, 2017</time>
        <h1 class="catalogue-title">FastD最佳实践二: 创建配置中心</h1>
        <div class="catalogue-line"></div>

        <p>
          过去专门做了一篇文档来构建配置中心，基于 zookeeper 的配置中心。 环境要求及构建步骤可参考: QConf搭建配置中心 随着业务增长，部署的机器可能会随着增长，增加配置难度和维护难度。配置会因为机器的增多而变得更加容易出错，为了解决这个问题，于是我们引入了 360 开发的 Qconf 来解决这个问题，目前已经稳定用于线上环境当中。 安装 qconf 扩展包 composer require fastd/qconf-service-provider -vvv  扩展包有点特殊，不需要任何的注册操作，当执行完 composer 依赖之后，会自动加载辅助函数，仅需对配置中心进行读取配置即可。 提供两个函数: qconf_get_value...
        </p>

      </div>
    </a>
  
    <a href="/2017-12-12/create-api" class="catalogue-item">
      <div>
        <time datetime="2017-12-12 00:00:00 +0800" class="catalogue-time">December 12, 2017</time>
        <h1 class="catalogue-title">FastD最佳实践一: 创建API</h1>
        <div class="catalogue-line"></div>

        <p>
          FastD 是一个专门针对 API 应用层而生的一个 PHP 应用框架，提供良好的中间件，路由以及支持 swoole 扩展运行，从而具体良好的性能条件。 创建项目 composer create-project fastd/dobee api -vvv  创建一个为 API 的项目。 运行第一个程序 进入命令行模式 php -S...
        </p>

      </div>
    </a>
  
</div>

<div class="pagination">
  
  

  <span>1</span>
</div>

    </main>

    <footer>
      <span>
        &copy; <time datetime="2017-12-21 15:25:55 +0800">2017</time> JanHuang. Made with Jekyll using the <a href="https://github.com/chesterhow/tale/">Tale</a> theme.
      </span>
    </footer>
  </body>
</html>
